/******************************************************************************
  Event trace translator
  Copyright (C) 2012 Sylvain Halle
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 ******************************************************************************/
package ca.uqac.info.trace.conversion;
import ca.uqac.info.ltl.*;
import ca.uqac.info.trace.*;
import ca.uqac.info.util.*;
import java.util.*;

/**
 * Translates an event trace into a NuSMV finite-state machine.
 * @author sylvain
 */
public class SmvTranslator implements Translator
{
  /**
   * Symbol standing for undefined
   */
  private final String m_undefinedSymbol = "UNDEF";
  
  public String translateTrace(EventTrace m_trace)
  {
    StringBuffer out = new StringBuffer();
    Relation<String,String> domains = m_trace.getParameterDomain();
    Set<String> params = domains.keySet();
    // State variable definitions
    out.append("-- Trace file automatically generated by\n-- Event Trace Converter\n\n");
    out.append("MODULE main\n\n");
    out.append("VAR\n");
    out.append("  m_num : {0..").append(m_trace.size() - 1).append("};\n");
    for (String p : params)
    {
      Set<String> dom = domains.get(p);
      out.append("  ").append(toSmvToken(p)).append(" : ").append(formatSet(dom)).append(";\n");
    }
    // Initial state definition
    out.append("\nINIT\n");
    out.append("m_num = 0 & (\n  ");
    out.append(toSmv(m_trace.firstElement(), false, params));
    out.append(")\n");
    // Transition relation
    out.append("\nTRANS\n");
    out.append("next(m_num) = m_num + 1 & (\n");
    for (int i = 0; i < m_trace.size(); i++)
    {
      if (i > 0)
        out.append("\n&\n");
      out.append("(next(m_num) = ").append(i).append(" ->\n  (");
      Event e = m_trace.elementAt(i);
      if (!e.isFlat() || e.isMultiValued())
      {
        out.append("-- WARNING: this event is not flat or is multi-valued\n");
      }
      out.append(toSmv(e, true, params));
      out.append(")");
      out.append(")");
    }
    out.append(")");
    return out.toString();
  }
  
  private StringBuffer toSmv(Event e, boolean is_next, Set<String> all_params)
  {
    StringBuffer out = new StringBuffer();
    Relation<String,String> domain = e.getParameterDomain();
    Set<String> params = domain.keySet();
    boolean first = true;
    for (String p : all_params)
    {
      if (!first)
        out.append(" & ");
      first = false;
      String p_name = p;
      if (is_next)
        p_name = "next(" + p + ")";
      if (!params.contains(p))
        out.append(p_name).append(" = ").append(m_undefinedSymbol);
      else
      {
        Set<String> values = domain.get(p);
        String val = "";
        // We get only the first value
        for (String v : values)
        {
          val = v;
          break;
        }
        out.append(p_name).append(" = ").append(toSmvToken(val));
      }
    }
    return out;
  }
  
  /**
   * Formats a set as a set of NuSMV tokens
   * @param s
   * @return
   */
  private StringBuffer formatSet(Set<String> s)
  {
    StringBuffer out = new StringBuffer();
    out.append("{");
    boolean first = true;
    for (String v : s)
    {
      if (!first)
        out.append(",");
      out.append(toSmvToken(v));
      first = false;
    }
    out.append("}");
    return out;
  }

  /**
   * Converts a value into a token acceptable by NuSMV
   * @param s
   */
  private static String toSmvToken(String s)
  {
    String out = new String(s);
    out.replace("_", "__");
    out.replace(".", "_d");
    out.replace(",", "_c");
    out.replace(";", "_l");
    out.replace(":", "_s");
    return out;
  }

  @Override
  public String translateFormula(Operator o)
  {
    StringBuffer out = new StringBuffer("LTLSPEC\n");
    out.append(translateFormulaRec(o));
    return out.toString();
  }
  
  public String translateFormulaRec(Operator o)
  {
    String out = "";
    if (o.getClass() == OperatorAnd.class)
      return translateFormulaRec((OperatorAnd) o);
    if (o.getClass() == OperatorOr.class)
      return translateFormulaRec((OperatorOr) o);
    if (o.getClass() == OperatorNot.class)
      return translateFormulaRec((OperatorNot) o);
    if (o.getClass() == OperatorEquals.class)
      return translateFormulaRec((OperatorEquals) o);
    if (o.getClass() == OperatorF.class)
      return translateFormulaRec((OperatorF) o);
    if (o.getClass() == OperatorG.class)
      return translateFormulaRec((OperatorG) o);
    if (o.getClass() == OperatorX.class)
      return translateFormulaRec((OperatorX) o);
    if (o.getClass() == Atom.class)
      return translateFormulaRec((Atom) o);
    return out;
  }
  
  protected String translateFormulaRec(OperatorF o)
  {
    StringBuffer out = new StringBuffer();
    out.append("F (").append(translateFormulaRec(o.getOperand())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorG o)
  {
    StringBuffer out = new StringBuffer();
    out.append("G (").append(translateFormulaRec(o.getOperand())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorX o)
  {
    StringBuffer out = new StringBuffer();
    out.append("X (").append(translateFormulaRec(o.getOperand())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorNot o)
  {
    StringBuffer out = new StringBuffer();
    out.append("! (").append(translateFormulaRec(o.getOperand())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorAnd o)
  {
    StringBuffer out = new StringBuffer();
    out.append("(").append(translateFormulaRec(o.getLeft())).append(")");
    out.append(" & (").append(translateFormulaRec(o.getRight())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorOr o)
  {
    StringBuffer out = new StringBuffer();
    out.append("(").append(translateFormulaRec(o.getLeft())).append(")");
    out.append(" | (").append(translateFormulaRec(o.getRight())).append(")");
    return out.toString();
  }
  
  protected String translateFormulaRec(OperatorEquals o)
  {
    StringBuffer out = new StringBuffer();
    out.append(translateFormulaRec(o.getLeft()));
    out.append(" = ").append(translateFormulaRec(o.getRight()));
    return out.toString();
  }
  
  protected String translateFormulaRec(Atom o)
  {
    return toSmvToken(o.getSymbol());
  }
}